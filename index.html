<!DOCTYPE html>
<html>
<body onload='init()'>

<div id='container' style="margin:auto;">
    <div id='clouds'></div>
</div>

<style>
    body {
        margin: 0;
    }
    #container {
        position: relative;
    }
    #container > * {
        position: absolute;
        left: 0;
    }

    #tree-canvas {
        z-index: 1
    }

    #clouds {
        background: linear-gradient(0deg, rgba(255,255,255,.2) 0%, rgba(0,0,0,.8) 100%);
        z-index: -6;
        width:100%;
        height:100%;
    }


    #background-lightning-canvas {
        z-index: -5;
    }
    #background-mountain-canvas {
        z-index: -5;
    }
    #midground-lightning-canvas {
        z-index: -3;
    }
    #foreground-mountain-canvas {
        z-index: -2;
    }
    #foreground-lightning-canvas {
        z-index: -1
    }

</style>

<script>

function cos(A) {
    return Math.cos(-Math.PI*(A/180));
}

function sin(A) {
    return Math.sin(-Math.PI*(A/180));
}

function getAngle(curA, deviation) {
    return (curA + Math.random()*(deviation*2)) - deviation;
}

function randInt(max) {
    return Math.floor(Math.random() * max)
}

function drawLightningSegment(lightning_jar, x, y, A, canvas) {
    console.log('new Lightning:', canvas);
    const new_jar = {
        branches: 1,
        unit: Math.random() * 7 + 8,
        strokes: [],
        created: new Date(),
        canvas: canvas
    };
    lightning_jar.push(new_jar);

    _drawLightningSegment(new_jar, x, y, A, 0);
}

function delayFn(fn, delay) {
    return (...props)=> setTimeout(()=> { 
            fn(...props)
        }, delay);
}

function getContext(id) {
    canvas = document.getElementById(id);
    if (!canvas) {
        canvas = document.createElement('canvas');
        canvas.width = WIDTH;
        canvas.height = HEIGHT;
        canvas.id = id;
        document.getElementById('container').appendChild(canvas)
    }
    return canvas.getContext("2d");
}

function _drawLightningSegment(jar, x, y, A, distance_from_arc) {
    if(x < 0 || x > WIDTH || y < 0 || y > HEIGHT) {
        --jar.branches;
        return 
    }
    ++jar.branches;

    const nX = x + jar.unit * cos(A) / (distance_from_arc + 1);
    const nY = y - jar.unit * sin(A) / (distance_from_arc + 1);


    const ratio = (3 * (canvas.height-nY) /* */) / canvas.height;
    const splitPct = ratio * .1 / (distance_from_arc + 1); // As distance from main arc increases, chance to split decreases
    const straightPct = ratio * .6 / (distance_from_arc + 1);
    const deviatePct = ratio * .9 / (distance_from_arc + 1);

    jar.strokes.push({x: x, nx: nX, y: y, ny: nY, distance_from_arc: distance_from_arc, created: new Date()})
    
    let n = Math.random();

    if (n <= splitPct) { 
        _drawLightningSegment(jar, nX, nY, (A - Math.random() * 15), distance_from_arc + 1);
        _drawLightningSegment(jar, nX, nY, (A + Math.random() * 15), distance_from_arc + 1);
    } 
    n = Math.random();

    if (n <= deviatePct) { 
        _drawLightningSegment(jar, nX, nY, getAngle(A, 15), distance_from_arc);
    }  
    --jar.num_branches;
    return;
}

_drawLightningSegment = delayFn(_drawLightningSegment, 20)

function draw(x,y,A) {
    if(x < 0 || x > WIDTH || y < 0 || y > HEIGHT) {
        return 
    }
    ++num_branches;
    ++total_branches;

    setTimeout(()=> {
        _draw(x,y,A);
    }, 30);
}

function _draw(x,y,A) {
    const unit = (Math.random() * 20 + 5)
    let nX = x + unit * cos(A);
    let nY = y + unit * sin(A);

    context = getContext('tree-canvas')
    context.beginPath();
    context.moveTo(x,y);
    context.lineTo(nX,nY);
    context.stroke();

    if(( Math.sinh(Math.abs(initialX - nX)/WIDTH ) + (initialY + 50 - nY)/HEIGHT ) >= 1 ) {
        num_branches--;
        return;
    }
    
    let n = Math.random();
    
    let ratio = 1.7*(nY)/(total_branches * (3 + 10*Math.random()));
    let angle_ratio = (90 - Math.abs(90 - A)) / 90;
    let straightPct = ratio * .4 * angle_ratio
    let deviatePct = ratio * .5 * angle_ratio
    let splitPct = ratio * .9 * angle_ratio

    if(n <= straightPct) {
        n = Math.random();
        if(n <= .2) {
            draw(nX, nY, getAngle(A, 15));
        }
        draw(nX, nY, A);
    } else if(n <= deviatePct) { 
        draw(nX, nY, getAngle(A, 15));
    } else if(n <= splitPct) { 
        if(Math.random() > .5) {
            draw(nX, nY, (A + Math.random()*15));
            draw(nX, nY, (A - Math.random()*15));
        } else {
            draw(nX, nY, (A - Math.random()*15));
            draw(nX, nY, (A + Math.random()*15));
        }
    }
    num_branches--;
    return;
}

function clear(context) {
    context.clearRect(0,0,WIDTH,HEIGHT);

    const gradient = context.createLinearGradient(0, WIDTH/2, 0, HEIGHT/2);
    gradient.addColorStop(0, "black");
    gradient.addColorStop(1, "white");

    // Fill with gradient
    context.fillStyle = gradient;
}

function Tree() {
    return new Promise( (res, _)=> {
        total_branches = 0;
        draw(initialX, initialY, 90,0,0);

        (function waitForCompletion() {
            if (!num_branches) return setTimeout(()=> res(null), 2500);
            setTimeout(waitForCompletion, 30);
        })();
    });
}

function buildMountainRange(mountain_range, num_mountains, based_around) {
    for (let i = 0; i < num_mountains; ++i) {
        let maybeNegative = 1;
        if (Math.random() > .5) maybeNegative *= -1;

        mountain_range.push({
            x: i*num_mountains,
            y: maybeNegative * Math.random() * HEIGHT / 100 + based_around,
            changeRate: Math.random() * maybeNegative
        });
    }
}

function drawMountainRange(canvas_id, mountain_range, fill_style) {
    const context = getContext(canvas_id, );
    context.clearRect(0, 0, WIDTH, HEIGHT);
    const region = new Path2D();
    region.moveTo(0, HEIGHT);
    mountain_range.map((mountain, index) => {
        region.lineTo(mountain.x, mountain.y);
        region.lineTo(mountain.x, mountain.y);
    });
    region.lineTo(WIDTH, HEIGHT);
    region.lineTo(0, HEIGHT);
    region.closePath();
    context.fillStyle = fill_style;
    context.fill(region);
}

let WIDTH;
let HEIGHT;

let initialX;
let initialY;
let num_branches = 0;
let total_branches = 0;
function init() {
    WIDTH = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
    HEIGHT = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
    initialX = WIDTH/2;
    initialY = HEIGHT;
    const container  = document.getElementById("container");
    container.style.height = HEIGHT+'px';
    container.style.width = WIDTH+'px';

    const tree_context = getContext('tree-canvas');

    let zen = 0;

    (async ()=> {
        while(1) {
            clear(tree_context);
            await Tree();
            console.log(`Tree${zen?'s':''}: ${++zen}`);
        }
    })();

    let rain_stick = [];
    let last_angle = 90;
    (tryRain = delayFn(() => {
        let next_rain = 0;
        let maybeNegativeAngle = 1;
        if (Math.random() > .5) maybeNegativeAngle *= -1;
        last_angle += maybeNegativeAngle * Math.random() * 3
        if (last_angle > 150) {
            last_angle = 150;
        }
        if (last_angle < 30) {
            last_angle = 30;
        }
        while (1) {
            next_rain += 50 * Math.random() + 5;
            if (next_rain >= WIDTH) {
                break;
            }
            let y_start = Math.random() * 25;
            let rain_unit = Math.random() * 10 + 5;
            let rain_angle = (maybeNegativeAngle * Math.random() * 10) + last_angle;
            const rain = {
                x1: next_rain,
                y1: y_start,
                x2: next_rain + cos(rain_angle) * rain_unit,
                y2: y_start + sin(rain_angle) * rain_unit,
                unit: rain_unit,
                angle: rain_angle,
                stroke: Math.random() * 3,
            };
            rain_stick.push(rain);
        }
        tryRain();
    }, 75))();

    let background_mountain_range = []
    let foreground_mountain_range = []

    buildMountainRange(background_mountain_range, WIDTH/15, HEIGHT * 2 / 3);
    buildMountainRange(foreground_mountain_range, WIDTH/10, HEIGHT * 4 / 5);

    (moveMountains = delayFn(() => {
        drawMountainRange('background-mountain-canvas', background_mountain_range, '#555');
        drawMountainRange('foreground-mountain-canvas', foreground_mountain_range, '#444');

        background_mountain_range = background_mountain_range.map((mountain, index) => {
            let maybeNegative = 1;
            if (Math.random() > .5) maybeNegative *= -1;
            
            mountain.changeRate += maybeNegative * Math.random();
            if (mountain.changeRate < -10) {
                mountain.changeRate = -10;
            }
            if (mountain.changeRate > 10) {
                mountain.changeRate = 10;
            }

            mountain.y += mountain.changeRate / 2;

            if (mountain.y > HEIGHT * 3 / 5) {
                mountain.changeRate -= Math.random() / 2;
            }
            if (mountain.y < HEIGHT * 3 / 5) {
                mountain.changeRate += Math.random() / 2;
            }
            return mountain;
        });
        foreground_mountain_range = foreground_mountain_range.map((mountain, index) => {
            let maybeNegative = 1;
            if (Math.random() > .5) maybeNegative *= -1;
            
            mountain.changeRate += maybeNegative * Math.random();
            if (mountain.changeRate < -10) {
                mountain.changeRate = -10;
            }
            if (mountain.changeRate > 10) {
                mountain.changeRate = 10;
            }

            mountain.y += mountain.changeRate / 3;

            if (mountain.y > HEIGHT * 8.5 / 10) {
                mountain.changeRate -= Math.random() / 2;
            }
            if (mountain.y < HEIGHT * 7.5 / 10) {
                mountain.changeRate += Math.random() / 2;
            }
            return mountain;
        });
        moveMountains();
    }, 50))();


    let lightning_jar = [];
    const lightning_canvases = ['foreground-lightning-canvas', 'midground-lightning-canvas', 'background-lightning-canvas'];
    (tryLightning = delayFn(() =>  {
        if (Math.random() < .015) {
            let maybeNegativeX = 1;
            if (Math.random() > .5) maybeNegativeX *= -1;
            const x_modifier = Math.random() * initialX * maybeNegativeX;

            let maybeNegativeAngle = 1;
            if (Math.random() > .5) maybeNegativeAngle *= -1;

            drawLightningSegment(lightning_jar, initialX + x_modifier, 0, 90 + maybeNegativeX * Math.random() * 15, lightning_canvases[randInt(lightning_canvases.length)]);
        }
        tryLightning()
    }, 30))();

    const lightningAge = 1*1000; 
    (lightningDrawLoop = delayFn(() =>  {
        lightning_canvases.map((canvas) =>
            getContext(canvas).clearRect(0, 0, WIDTH, HEIGHT)
        );
        lightning_jar = lightning_jar.filter((jar, index) => {
            // Delete lightning jar if no segments remain
            if (!jar.strokes.length && jar.created < new Date() - lightningAge) {
                return false;
            }
            const context = getContext(jar.canvas);
            jar.strokes = jar.strokes.filter(stroke => {
                // Delete if last lightning segment is older than maximum age
                if (stroke.created < new Date() - lightningAge) {
                    return false;
                }
                context.strokeStyle = `rgb(${170 + (75 * ( 1 / (stroke.distance_from_arc + 1)))}, ${170 + (75 * ( 1 / (stroke.distance_from_arc + 1)))}, 255, ${1 - ((new Date() - stroke.created) / (lightningAge))}`;
                context.beginPath();
                context.moveTo(stroke.x, stroke.y);
                context.lineTo(stroke.nx, stroke.ny);
                context.lineWidth = 3 * (1 / (stroke.distance_from_arc + 1));

                context.stroke();
                return true;
            });
            return true;
        });
        lightningDrawLoop()
    }, 30))();

    (rainDrawLoop = delayFn(() => {
        const context = getContext('rain-canvas');
        context.clearRect(0,0,WIDTH, HEIGHT);
        rain_stick = rain_stick.filter((rain, index) => {
            if (rain.y1 >= HEIGHT) {
                return false;
            }
            context.strokeStyle = `rgb(0, 0, 0, ${rain.stroke / 9}`;
            context.lineWidth = rain.stroke;
            context.beginPath();
            context.moveTo(rain.x1, rain.y1);
            context.lineTo(rain.x2, rain.y2);
            context.stroke();
            
            if (rain.x2 >= WIDTH) {
                context.beginPath();
                context.moveTo(rain.x1 - WIDTH, rain.y1);
                context.lineTo(rain.x2 - WIDTH, rain.y2);
                context.stroke();
            }
            if (rain.x1 <= 0) {
                context.beginPath();
                context.moveTo(rain.x1 + WIDTH, rain.y1);
                context.lineTo(rain.x2 + WIDTH, rain.y2);
                context.stroke();
            }

            rain.x1 = rain.x2;
            rain.y1 = rain.y2;
            rain.x2 = rain.x1 + cos(rain.angle) * rain.unit;
            rain.y2 = rain.y1 - sin(rain.angle) * rain.unit * 3;

            if (rain.x1 <= 0) {
                rain.x1 += WIDTH
                rain.x2 += WIDTH
            }

            if (rain.x1 >= WIDTH) {
                rain.x1 -= WIDTH
                rain.x2 -= WIDTH
            }

            return true;
        });
        rainDrawLoop();
    }, 30))();
}


</script>

</body>
</html>

